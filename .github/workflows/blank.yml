# This is a basic workflow to help you get started with Actions

name: CI

# Controls when the workflow will run
on:
  # Triggers the workflow on push or pull request events but only for the "main" branch
  push:
    branches: [ "main" ]
  pull_request:
    branches: [ "main" ]

  # Allows you to run this workflow manually from the Actions tab
  workflow_dispatch:

# A workflow run is made up of one or more jobs that can run sequentially or in parallel
jobs:
  # This workflow contains a single job called "build"
  build:
    # The type of runner that the job will run on
    runs-on: ubuntu-latest

    # Steps represent a sequence of tasks that will be executed as part of the job
    steps:
      # Checks-out your repository under $GITHUB_WORKSPACE, so your job can access it
      - uses: actions/checkout@v4

      # Runs a single command using the runners shell
      - name: Run a one-line script
        run: echo Hello, world!

      # Runs a set of commands using the runners shell
      - name: Run a multi-line script
        run: |
          echo Add other actions to build,
          echo test, and deploy your project.
import asyncio
import logging
from os import getenv
from aiogram import Bot, Dispatcher, html
from aiogram.client.default import DefaultBotProperties
from aiogram.enums import ParseMode
from aiogram.filters import CommandStart
from aiogram.types import Message
from aiogram.fsm.storage.memory import MemoryStorage
from openai import AsyncOpenAI
from dotenv import load_dotenv

# ────────────────────────────────────────────────
# Настройки и окружение
# ────────────────────────────────────────────────
load_dotenv()
TELEGRAM_TOKEN = getenv("TELEGRAM_TOKEN")
OPENAI_API_KEY = getenv("OPENAI_API_KEY")
ALLOWED_USERS = {123456789, 987654321}

# Системный промпт
SYSTEM_PROMPT = """
Ты - AI-аналитик для менеджеров. Твоя задача - анализировать предоставленный текст и давать структурированный ответ.
Структура ответа:

Ключевые моменты: Перечисли основные идеи.
Рекомендации: Предложи действия на основе анализа.
Риски: Укажи потенциальные проблемы.
Анализируй текст объективно и конструктивно.
"""

# ────────────────────────────────────────────────
# Инициализация
# ────────────────────────────────────────────────
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s | %(levelname)s | %(name)s | %(message)s",
)
bot = Bot(
    token=TELEGRAM_TOKEN,
    default=DefaultBotProperties(parse_mode=ParseMode.HTML)
)
dp = Dispatcher(storage=MemoryStorage())
openai_client = AsyncOpenAI(api_key=OPENAI_API_KEY)

# ────────────────────────────────────────────────
# Хендлеры
# ────────────────────────────────────────────────
@dp.message(CommandStart())
async def cmd_start(message: Message):
    if message.from_user.id not in ALLOWED_USERS:
        await message.answer("Доступ запрещён. Вы не в белом списке.")
        return
    await message.answer(
        f"Привет, {html.bold(message.from_user.full_name)}!\n"
        "Отправь мне текст для анализа."
    )

@dp.message()
async def analyze_text(message: Message):
    if message.from_user.id not in ALLOWED_USERS:
        await message.answer("Доступ запрещён. Вы не в белом списке.")
        return
    user_text = message.text.strip()
    if not user_text:
        await message.answer("Пустое сообщение. Отправь текст для анализа.")
        return
    try:
        response = await openai_client.chat.completions.create(
            model="gpt-4o-mini",
            messages=[
                {"role": "system", "content": SYSTEM_PROMPT},
                {"role": "user", "content": user_text},
            ],
            temperature=0.3,
            max_tokens=1500,
        )
        ai_text = response.choices[0].message.content
        await message.answer(ai_text)
    except Exception as e:
        logging.exception("Ошибка при обращении к OpenAI")
        await message.answer(f"Произошла ошибка: {html.code(str(e))}")

# ────────────────────────────────────────────────
# Запуск
# ────────────────────────────────────────────────
async def main():
    await bot.delete_webhook(drop_pending_updates=True)
    await dp.start_polling(
        bot,
        allowed_updates=["message"],
    )

if __name__ == "__main__":
    try:
        asyncio.run(main())
    except (KeyboardInterrupt, SystemExit):
        logging.info("Бот остановлен")
